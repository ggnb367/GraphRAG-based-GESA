"""
Compute GSEA-style enrichment scores (ES) and normalized enrichment scores (NES)
using permutation-based null distributions.

The script reads a pre-ranked gene list (``temp.rnk``-style, two columns of gene
symbol and numeric score) and a compact knowledge graph JSON generated by
``KG_preprocessing.py``. For each term (source node linked to gene targets), the
algorithm:

1. Builds a running enrichment statistic over the ranked gene list using the
   provided weight (``weight=1`` by default). Hit increments are ``|score|^weight``
   normalized by the total weighted hit score sum; misses decrement uniformly by
   ``1/Nmiss``.
2. The enrichment score (``ES``) is the maximum absolute deviation of this
   running sum; positive values indicate enrichment toward the top of the list,
   negative values toward the bottom.
3. A permutation-based null distribution is generated by shuffling gene labels
   (default ``nperm=1000``). Positive and negative null means are computed
   separately, and the observed ES is normalized accordingly to obtain ``NES``:
   ``ES/mean_pos`` if ``ES>0`` else ``-ES/mean_neg``. The null ES values are
   likewise normalized for downstream p-value/FDR calculations if needed.

Outputs are written to ``GSEA_gseapy_output.txt`` with the term label, dataset,
ES, NES, and NES-ranked order (sorted by NES descending, then term label).
"""
from __future__ import annotations

import argparse
import json
import random
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Sequence, Tuple


@dataclass(frozen=True)
class RankedGene:
    name: str
    score: float


GeneScores = Dict[str, float]


def load_ranked_genes(path: Path) -> List[RankedGene]:
    """Load ranked genes preserving file order."""

    ranked: List[RankedGene] = []
    with path.open(encoding="utf-8") as handle:
        for line_no, line in enumerate(handle, start=1):
            stripped = line.strip()
            if not stripped:
                continue
            parts = stripped.split()
            if len(parts) < 2:
                raise ValueError(f"Invalid line #{line_no} in {path}: expected gene and score")
            gene, score_text = parts[0], parts[1]
            ranked.append(RankedGene(gene, float(score_text)))
    return ranked


def load_kg(path: Path) -> Dict[str, object]:
    """Load the compact knowledge graph JSON."""

    with path.open(encoding="utf-8") as handle:
        return json.load(handle)


def build_term_gene_maps(triples: Sequence[Dict[str, str]]) -> Tuple[Dict[str, List[str]], Dict[str, List[str]]]:
    """Create mappings from term labels to genes and datasets (relations)."""

    term_to_genes: Dict[str, List[str]] = defaultdict(list)
    term_to_datasets: Dict[str, List[str]] = defaultdict(list)
    for triple in triples:
        term_label = triple["source_label"]
        gene_label = triple["target_label"]
        relation = triple["relation"]
        term_to_genes[term_label].append(gene_label)
        term_to_datasets[term_label].append(relation)
    return term_to_genes, term_to_datasets


def format_dataset_label(relations: Iterable[str]) -> str:
    """Create a stable dataset label string from relations."""

    unique = sorted(set(relations))
    return ",".join(unique)


def enrichment_score(
    ranked_genes: List[RankedGene], term_genes: Sequence[str], weight: float
) -> float:
    """Compute the running enrichment score for a term.

    Parameters
    ----------
    ranked_genes: List of RankedGene objects ordered by rank.
    term_genes: Sequence of gene names belonging to the term.
    weight: Exponent applied to |score|; ``0`` uses uniform weights.
    """

    term_gene_set = set(term_genes)
    hits = [gene for gene in ranked_genes if gene.name in term_gene_set]
    num_hits = len(hits)
    n = len(ranked_genes)
    num_miss = n - num_hits

    if num_hits == 0:
        return 0.0
    if num_miss == 0:
        return 1.0

    if weight == 0:
        hit_weights = [1.0 for _ in hits]
    else:
        hit_weights = [abs(g.score) ** weight for g in hits]

    sum_hit_weights = sum(hit_weights)
    norm_hit = 1.0 / sum_hit_weights if sum_hit_weights != 0 else 0.0
    norm_miss = 1.0 / num_miss

    running = 0.0
    max_deviation = 0.0

    hit_weight_lookup = {g.name: w for g, w in zip(hits, hit_weights)}

    for gene in ranked_genes:
        if gene.name in term_gene_set:
            increment = hit_weight_lookup.get(gene.name, 0.0) * norm_hit
        else:
            increment = -norm_miss
        running += increment
        if abs(running) > abs(max_deviation):
            max_deviation = running

    return max_deviation


def compute_es_and_null(
    ranked_genes: List[RankedGene],
    term_genes: Sequence[str],
    weight: float,
    nperm: int,
    rng: random.Random,
) -> Tuple[float, List[float]]:
    """Compute observed ES and permutation-based null ES values."""

    es_obs = enrichment_score(ranked_genes, term_genes, weight)

    gene_names = [g.name for g in ranked_genes]
    es_null: List[float] = []
    for _ in range(nperm):
        permuted = gene_names[:]
        rng.shuffle(permuted)
        perm_ranked = [RankedGene(name, score=rg.score) for name, rg in zip(permuted, ranked_genes)]
        es_null.append(enrichment_score(perm_ranked, term_genes, weight))
    return es_obs, es_null


def normalize_es(es_obs: float, es_null: Sequence[float]) -> float:
    """Normalize ES using positive/negative null means."""

    pos = [es for es in es_null if es > 0]
    neg = [-es for es in es_null if es < 0]

    mean_pos = sum(pos) / len(pos) if pos else 0.0
    mean_neg = sum(neg) / len(neg) if neg else 0.0

    if es_obs > 0:
        return es_obs / mean_pos if mean_pos != 0 else 0.0
    if es_obs < 0:
        return -es_obs / mean_neg if mean_neg != 0 else 0.0
    return 0.0


def compute_scores(
    ranked_genes: List[RankedGene],
    term_to_genes: Dict[str, List[str]],
    weight: float,
    nperm: int,
    seed: int | None,
) -> Tuple[Dict[str, float], Dict[str, float]]:
    """Compute ES and NES for each term."""

    rng = random.Random(seed)
    term_es: Dict[str, float] = {}
    term_nes: Dict[str, float] = {}

    for term, genes in term_to_genes.items():
        es_obs, es_null = compute_es_and_null(ranked_genes, genes, weight, nperm, rng)
        term_es[term] = es_obs
        term_nes[term] = normalize_es(es_obs, es_null)

    return term_es, term_nes


def write_output(
    output_path: Path,
    term_es: Dict[str, float],
    term_nes: Dict[str, float],
    term_to_datasets: Dict[str, List[str]],
) -> None:
    """Write sorted term ES/NES with dataset and rank to a file."""

    sorted_terms = sorted(term_nes.items(), key=lambda item: (-item[1], item[0]))

    lines = ["term_label\tdataset\tES\tNES\trank"]
    for idx, (term, nes_score) in enumerate(sorted_terms, start=1):
        dataset_label = format_dataset_label(term_to_datasets.get(term, []))
        es_score = term_es.get(term, 0.0)
        lines.append(f"{term}\t{dataset_label}\t{es_score}\t{nes_score}\t{idx}")

    output_path.write_text("\n".join(lines), encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Compute GSEA-style ES/NES scores from a compact KG and ranked genes.",
    )
    parser.add_argument(
        "--rnk", type=Path, default=Path("temp.rnk"), help="Path to the ranked gene list file.",
    )
    parser.add_argument(
        "--kg", type=Path, default=Path("data/compact_kg.json"), help="Path to the compact KG JSON file.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("GSEA_gseapy_output.txt"),
        help="Destination file for term scores and ranks.",
    )
    parser.add_argument("--weight", type=float, default=1.0, help="Weight exponent for |score|.")
    parser.add_argument("--nperm", type=int, default=1000, help="Number of permutations for ES null.")
    parser.add_argument(
        "--seed",
        type=int,
        default=None,
        help="Random seed for reproducible permutations.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    ranked_genes = load_ranked_genes(args.rnk)
    kg = load_kg(args.kg)

    term_to_genes, term_to_datasets = build_term_gene_maps(kg.get("triples", []))
    term_es, term_nes = compute_scores(
        ranked_genes, term_to_genes, weight=args.weight, nperm=args.nperm, seed=args.seed
    )

    output_path = args.output if args.output.is_absolute() else args.output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    write_output(output_path, term_es, term_nes, term_to_datasets)

    print(f"Wrote term scores for {len(term_es)} terms to {output_path}")


if __name__ == "__main__":
    main()